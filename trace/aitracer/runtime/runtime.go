package runtime

import (
	"runtime"
	"strconv"
	"sync"
	"time"

	"github.com/volcengine/apminsight-server-sdk-go/metrics"
	"github.com/volcengine/apminsight-server-sdk-go/trace/aitracer/service_register/register_utils"
)

// runtime metrics is generated by metricClient
var logfunc func(string, ...interface{})

type Config struct {
	intervalSeconds int64 // time interval between two stats read
	tagsList        []map[string]string
}

func newDefaultConfig() *Config {
	return &Config{
		intervalSeconds: 30,
	}
}

type Option func(*Config)

// WithAdditionalTags add tags
func WithAdditionalTags(tags map[string]string) Option {
	return func(config *Config) {
		config.tagsList = append(config.tagsList, tags)
	}
}

func SetLogFunc(_logfunc func(string, ...interface{})) {
	logfunc = _logfunc
}

type stats struct {
	goRoutine int
	cgoCall   int64
	*runtime.MemStats
}

type Monitor struct {
	metricsClient *metrics.MetricsClient

	intervalSeconds int64
	tags            map[string]string

	serviceType string
	service     string
	instanceId  string
	pid         string
	createTime  string
	containerId string

	closeChan chan struct{}
	wg        sync.WaitGroup

	preStats *stats
}

func NewMonitor(serviceType, service string, mc *metrics.MetricsClient, opts ...Option) *Monitor {
	if mc == nil {
		mc = metrics.NewMetricClient()
	}

	cfg := newDefaultConfig()
	for _, opt := range opts {
		opt(cfg)
	}

	info, _ := register_utils.GetInfo()
	rm := &Monitor{
		metricsClient:   mc,
		intervalSeconds: cfg.intervalSeconds,

		serviceType: serviceType,
		service:     service,
		instanceId:  register_utils.GetInstanceID(),
		pid:         strconv.FormatInt(int64(info.Pid), 10),
		createTime:  strconv.FormatInt(info.StartTime, 10),
		containerId: info.ContainerId,
		closeChan:   make(chan struct{}),
	}

	// add tags
	tags := make(map[string]string)
	for _, ts := range cfg.tagsList {
		for k, v := range ts {
			tags[k] = v
		}
	}
	tags["service_type"] = serviceType
	tags["service"] = rm.service
	tags["instance_id"] = rm.instanceId
	//tags["pid"] = rm.pid        //in docker pid is actually NSPid. should be ignored.
	tags["create_time"] = rm.createTime
	tags["container_id"] = rm.containerId
	rm.tags = tags

	return rm
}

func (r *Monitor) Start() {
	r.metricsClient.Start()
	r.wg.Add(1)
	go func() {
		tc := time.NewTicker(time.Duration(r.intervalSeconds) * time.Second)
		defer func() {
			tc.Stop()
			r.wg.Done()
		}()
		r.run()
		for {
			select {
			case <-tc.C:
				r.run()
			case <-r.closeChan:
				break
			}
		}
	}()
	if logfunc != nil {
		logfunc("[Monitor] Start success")
	}
}

func (r *Monitor) Close() {
	r.metricsClient.Close()
	close(r.closeChan)
	r.wg.Wait()

}

func (r *Monitor) readStats() *stats {
	ms := runtime.MemStats{} //mem
	runtime.ReadMemStats(&ms)
	return &stats{
		goRoutine: runtime.NumGoroutine(), //goroutines
		cgoCall:   runtime.NumCgoCall(),   //cgo call
		MemStats:  &ms,
	}
}

func (r *Monitor) run() {
	curStats := r.readStats()
	preStats := &stats{
		goRoutine: 0,
		cgoCall:   0,
		MemStats:  &runtime.MemStats{},
	}
	if r.preStats != nil {
		preStats = r.preStats
	}

	defer func() {
		r.preStats = curStats // update preStats
	}()

	// emit metric
	if logfunc != nil && curStats != nil && curStats.MemStats != nil {
		logfunc("[Monitor] running. stats: goRoutine=%+v , cgoCall=%+v , MemStat=%+v", curStats.goRoutine, curStats.cgoCall, *curStats.MemStats)
	}

	// goroutine num
	_ = r.metricsClient.EmitGauge(metricGoRuntimeGoRoutineNum, float64(curStats.goRoutine), r.tags)

	// cgo call. cumulative
	_ = r.metricsClient.EmitCounter(metricGoRuntimeCgoCallCount, float64(curStats.cgoCall-preStats.cgoCall), r.tags)

	// gc num. cumulative
	_ = r.metricsClient.EmitCounter(metricGoRuntimeGcCount, float64(curStats.NumGC-preStats.NumGC), r.tags)

	// totalGcTime. currentTotalNs - lastTotalNs is gcTime between sample interval
	_ = r.metricsClient.EmitCounter(metricGoRuntimeGcCostTotal, float64(curStats.PauseTotalNs-preStats.PauseTotalNs)/1000, r.tags)

	// single gc time
	for _, gcPauseNs := range getGcPausesNs(curStats.PauseNs[:], preStats.NumGC, curStats.NumGC) {
		_ = r.metricsClient.EmitTimer(metricGoRuntimeGcCostDistribute, float64(gcPauseNs)/1000, r.tags)
	}

	// Heap
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsHeapAlloc, float64(curStats.HeapAlloc), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsHeapSys, float64(curStats.HeapSys), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsHeapIdle, float64(curStats.HeapIdle), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsHeapInuse, float64(curStats.HeapInuse), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsHeapReleased, float64(curStats.HeapReleased), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsHeapObjets, float64(curStats.HeapObjects), r.tags)

	// pointer lookups
	_ = r.metricsClient.EmitCounter(metricGoRuntimeMemStatsLookups, float64(curStats.Lookups-preStats.Lookups), r.tags)

	// Stack
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsStackInuse, float64(curStats.StackInuse), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsStackSys, float64(curStats.StackSys), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsMSpanInuse, float64(curStats.MSpanInuse), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsMSpanSys, float64(curStats.MSpanSys), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsMCacheInuse, float64(curStats.MCacheInuse), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsMCacheSys, float64(curStats.MCacheSys), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsBuckHashSys, float64(curStats.BuckHashSys), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsGcSys, float64(curStats.GCSys), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsOtherSys, float64(curStats.OtherSys), r.tags)

	// gc related metric
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsNextGc, float64(curStats.NextGC), r.tags)
	_ = r.metricsClient.EmitCounter(metricGoRuntimeMemStatsNumForcedGc, float64(curStats.NumForcedGC-preStats.NumForcedGC), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsGCCPUFraction, curStats.GCCPUFraction, r.tags)

	// derived metric
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsLiveObjects, float64(curStats.Mallocs-curStats.Frees), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsHeapRetained, float64(curStats.HeapIdle-curStats.HeapReleased), r.tags)
	_ = r.metricsClient.EmitGauge(metricGoRuntimeMemStatsHeapFragment, float64(curStats.HeapInuse-curStats.Alloc), r.tags)
}

func getGcPausesNs(pauseNs []uint64, preNumGc, curNumGc uint32) []uint64 {
	count := int(curNumGc) - int(preNumGc)
	if count <= 0 {
		return nil
	}
	if count >= len(pauseNs) {
		return pauseNs
	}

	length := uint32(len(pauseNs))
	i := preNumGc % length
	j := curNumGc % length
	if j < i {
		part := pauseNs[i:]
		part = append(part, pauseNs[:j]...)
		return part
	}
	return pauseNs[i:j]
}
